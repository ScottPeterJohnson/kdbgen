package net.justmachinery.kdbgen.kapt

import org.intellij.lang.annotations.Language
import kotlin.reflect.KClass

@Retention(AnnotationRetention.SOURCE)
annotation class SqlGenerationSettings(
    /**
     * URL of database to connect to (including user/pass)
     */
    val databaseUrl : String,
    /**
     * Directory to output generated source files to
     * Defaults to kapt
     */
    val outputDirectory : String = "",
    val preludeOutputDirectory : String = ""
)

@Suppress("DEPRECATED_JAVA_ANNOTATION")
@Target(
    AnnotationTarget.CLASS,
    AnnotationTarget.TYPE,
    AnnotationTarget.PROPERTY,
    AnnotationTarget.FUNCTION,
    AnnotationTarget.CONSTRUCTOR,
    AnnotationTarget.FIELD,
    AnnotationTarget.PROPERTY_GETTER,
    AnnotationTarget.PROPERTY_SETTER
)
@Repeatable
@java.lang.annotation.Repeatable(SqlQueries::class)
@Retention(AnnotationRetention.SOURCE)
annotation class SqlQuery(
    /**
     * Name of the query function to generate/
     */
    val name : String,
    /**
     * SQL query to run. Anything JDBC will accept.
     */
    @Language("PostgreSQL")
    val query : String,
    /**
     * Name of the result class to generate for this query.
     * If the same name is shared among multiple SqlQuery annotations, they must all have the same outputs.
     * If fully qualified, an existing class will be used. Its primary constructor should accept the same named parameters.
     */
    val resultName : String = "",

    /**
     * If provided, overrides inference for the nullability of columns in the output.
     */
    val columnCanBeNull : BooleanArray = [],
    /**
     * An optional array of names for the sub-result sets of this query, if multiple.
     * E.g. if a query has two result sets, its "resultName" is Foo, and it returns two ResultSets Bar and Baz,
     * the resulting class will be Foo(Bar, Baz).
     * A blank string will use the autogenerated name.
     */
    val subResultNames : Array<String> = []

)

@Retention(AnnotationRetention.SOURCE)
@Target(
    AnnotationTarget.CLASS,
    AnnotationTarget.TYPE,
    AnnotationTarget.PROPERTY,
    AnnotationTarget.FUNCTION,
    AnnotationTarget.CONSTRUCTOR,
    AnnotationTarget.FIELD,
    AnnotationTarget.PROPERTY_GETTER,
    AnnotationTarget.PROPERTY_SETTER
)
annotation class SqlQueries(vararg val value : SqlQuery)

@Target(
    AnnotationTarget.CLASS,
    AnnotationTarget.TYPE,
    AnnotationTarget.PROPERTY
)
@Retention(AnnotationRetention.SOURCE)
annotation class QueryContainer

/**
 * Allows you to specify code that that runs when a connection is created, and hence exists before every processed query.
 * You can use this to e.g. define temporary views that can then be referenced from other queries.
 */
@Suppress("DEPRECATED_JAVA_ANNOTATION")
@Target(
    AnnotationTarget.CLASS,
    AnnotationTarget.TYPE,
    AnnotationTarget.PROPERTY,
    AnnotationTarget.FUNCTION,
    AnnotationTarget.CONSTRUCTOR,
    AnnotationTarget.FIELD,
    AnnotationTarget.PROPERTY_GETTER,
    AnnotationTarget.PROPERTY_SETTER
)
@Repeatable
@java.lang.annotation.Repeatable(SqlPreludes::class)
@Retention(AnnotationRetention.SOURCE)
annotation class SqlPrelude(
    /**
     * SQL to execute
     */
    @Language("PostgreSQL")
    val sql : String,
    /**
     * Allows you to control the ordering of combined sql by specifying other classes annotated with [SqlTempView] to be added first.
     */
    vararg val dependencies : KClass<out Any> = []
)

@Retention(AnnotationRetention.SOURCE)
@Target(
    AnnotationTarget.CLASS,
    AnnotationTarget.TYPE,
    AnnotationTarget.PROPERTY,
    AnnotationTarget.FUNCTION,
    AnnotationTarget.CONSTRUCTOR,
    AnnotationTarget.FIELD,
    AnnotationTarget.PROPERTY_GETTER,
    AnnotationTarget.PROPERTY_SETTER
)
annotation class SqlPreludes(vararg val value : SqlPrelude)